<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Fireworks</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				background-color: #000000;
				margin: 0px;
				overflow: hidden;
				font-family:Monospace;
				font-size:13px;
				text-align:center;
				font-weight: bold;
				text-align:center;
			}

			a {
				color:#0078ff;
			}

			#info {
				color: #fff;
				position: absolute;
				top: 0px; width: 100%;
				padding: 5px;
				z-index: 100;
			}

		</style>
	</head>
	<body>

		<script src="build/three.js"></script>

		<script src="js/Detector.js"></script>
		<script src="js/libs/stats.min.js"></script>

		<script>

			if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

      //Global variables

			var container, stats;
			var camera, scene, renderer, particles,  materials = [], parameters, i, j, h, color, size, lines = [];
			var lineparam, lineparameters, linematerials = [], linesgeometry = [];
			var vertexstart, vertexend, fireworksDirection;
			var mouseX = 0, mouseY = 0;
			var speed = 3;
			var nooffireworks = 60;
			var allFireworksReachedDestination = 0;

			var windowHalfX = window.innerWidth / 2;
			var windowHalfY = window.innerHeight / 2;
      var clock = new THREE.Clock();
			var linelength = 30;
			var frameTime = 0;
			var distancetravelled = 0;

			var geometryend = new THREE.Geometry();
			var directiongeometry = new THREE.Geometry();
			var distanceArray = new Array(nooffireworks);

			//FireWorks variables
			var ticker = 0;
			var tickermax = 80;
      var fwstart, fwend, fwcurrent, fwDirection;
			var fwGeometry, fwparameters, fwparam, fwmaterials = [], fwline;

			init();
			animate();

			// get a random number within a range
			function random( min, max ) {
				return Math.random() * ( max - min ) + min;
			}

			//Remove entity from scene
			function removeEntity(selectedObject)
			 {
    			//var selectedObject = scene.getObjectByName(name);
    			scene.remove( selectedObject );
    		  animate();
			}

			function initData()
			{
				for ( i = 0; i < nooffireworks; i ++ ) {
					//End points of the fireworks
					vertexend = new THREE.Vector3();
					vertexend.x = Math.random() * 2000 - 1000;
					vertexend.y = Math.random() * 2000 - 1000;
					vertexend.z = Math.random() * 2000 - 1000;
					geometryend.vertices.push( vertexend );

					//Starting point of the fireworks
  				vertexstart = new THREE.Vector3();
					vertexstart.x = windowHalfX - 1000;
					vertexstart.y = windowHalfY - 1000;
					vertexstart.z = 1000;

					//Compute distance between these two and the direction
					var d = vertexstart.distanceTo( vertexend );
					distanceArray[i] = d;
					fireworksDirection = new THREE.Vector3();
					fireworksDirection.subVectors( vertexend, vertexstart).normalize();
					directiongeometry.vertices.push( fireworksDirection );

					//Currents point of the fireworks. lets keep the length of the line at 100 units
					vertexcurrent = new THREE.Vector3();
					vertexcurrent.x = (windowHalfX - 1000) + ((fireworksDirection.x) * linelength);
					vertexcurrent.y = (windowHalfY - 1000) + ((fireworksDirection.y) * linelength);
					vertexcurrent.z = 1000 								 + ((fireworksDirection.z) * linelength);

					//Create a line from start to current
					lineparameters = [
						//[ 0.25, 0xff9900, 1, 4 ],
						//[ 0.5, 0xff9900, 1, 1 ],
						//[ 0.75, 0xffaa00, 0.75, 1 ],
						[ 1, 0xffaa00, 0.5, 1 ],
						//[ 1.25, 0x000833, 0.8, 1 ],
					];

					linesgeometry[i] = new THREE.Geometry();
					linesgeometry[i].vertices.push( new THREE.Vector3(vertexstart.x, vertexstart.y, vertexstart.z) );
					linesgeometry[i].vertices.push( new THREE.Vector3(vertexcurrent.x, vertexcurrent.y, vertexcurrent.z) );

					//Draws line from origin to all random points
					lineparam = lineparameters[ 0 ];
					linematerials[0] = new THREE.LineBasicMaterial( { color: lineparam[ 1 ], opacity: lineparam[ 2 ], linewidth: lineparam[ 3 ] } );
					lines[i] = new THREE.LineSegments( linesgeometry[i], linematerials[0] );
					lines[i].name = "_fireworks"+ i;
          scene.add( lines[i] );
				}
			}

			function initScene()
			{
				parameters = [
					[ [1, 1, 0.5], 5 ],
					//[ [1, 1, 0.5], 5 ],
					//[ [1, 1, 0.5], 5 ],
					//[ [1, 1, 0.5], 5 ],
					//[ [1, 1, 0.5], 5 ]
				];
        var p;
				for ( i = 0; i < parameters.length; i ++ ) {

					color = parameters[i][0];
					size  = parameters[i][1];

					materials[i] = new THREE.PointsMaterial( { size: size } );
  				particles = new THREE.Points( geometryend, materials[i] );
					scene.add( particles );
				}
			}

			function init()
			 {

				container = document.createElement( 'div' );
				document.body.appendChild( container );

				camera = new THREE.PerspectiveCamera( 100, window.innerWidth / window.innerHeight, 1, 3000 );
				camera.position.z = 1500;

				scene = new THREE.Scene();
				scene.fog = new THREE.FogExp2( 0x000000, 0.0007 );

        //Initialize the data
			  initData();

				//Initialize scene
				initScene();


				//Initialize fireworks every time the tickercount is reached
        // if(ticker > tickercount)
				// {
				// 	ticker = 0;
				//   initFireWorks();
				// 	initFireWorksScene();
				// }
				// ticker++;

				renderer = new THREE.WebGLRenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				container.appendChild( renderer.domElement );

				stats = new Stats();
				container.appendChild( stats.dom );

				document.addEventListener( 'mousemove', onDocumentMouseMove, false );
				document.addEventListener( 'touchstart', onDocumentTouchStart, false );
				document.addEventListener( 'touchmove', onDocumentTouchMove, false );
				window.addEventListener( 'resize', onWindowResize, false );
			}

			function onWindowResize() {

				windowHalfX = window.innerWidth / 2;
				windowHalfY = window.innerHeight / 2;

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function onDocumentMouseMove( event ) {

				mouseX = event.clientX - windowHalfX;
				mouseY = event.clientY - windowHalfY;

			}

			function onDocumentTouchStart( event ) {

				if ( event.touches.length === 1 ) {

					event.preventDefault();

					mouseX = event.touches[ 0 ].pageX - windowHalfX;
					mouseY = event.touches[ 0 ].pageY - windowHalfY;

				}

			}

			function onDocumentTouchMove( event ) {

				if ( event.touches.length === 1 ) {

					event.preventDefault();

					mouseX = event.touches[ 0 ].pageX - windowHalfX;
					mouseY = event.touches[ 0 ].pageY - windowHalfY;

				}

			}

			//Function to update the lines
      function UpdateLines() {
			for ( i = 0; i < linesgeometry.length; i++ )
				{
					var lineObject = linesgeometry[ i ];
					var fromPoint = lineObject.vertices[ 0 ];
					var toPoint   = lineObject.vertices[ 1 ];
					var endPoint  = geometryend.vertices[i];

					if ( toPoint instanceof THREE.Vector3 )
					{
						//If we are at the destination then we just need to disperse the fire particles
						var distance = vertexstart.distanceTo( toPoint );
						if(distance > distanceArray[i])
						{
              lines[i].visible = false;
						}
					else
					 {
						//Calculate the distance travelled in the elaspsed time and hence the new toPoint
						distancetravelled = speed * frameTime * 10;
						var directionVertice = directiongeometry.vertices[ i ];
						var newPoint;
						if ( directionVertice instanceof THREE.Vector3 )
						{
							newPoint = new THREE.Vector3();
							toPoint.x = toPoint.x + ((directionVertice.x) * distancetravelled);
							toPoint.y = toPoint.y + ((directionVertice.y) * distancetravelled);
							toPoint.z = toPoint.z + ((directionVertice.z) * distancetravelled);
						}

						//Update the fromPoint to trail linelength behind toPoint
						 fromPoint.x = toPoint.x + ((directionVertice.x) * -linelength);
						 fromPoint.y = toPoint.y + ((directionVertice.y) * -linelength);
						 fromPoint.z = toPoint.z + ((directionVertice.z) * -linelength);

						//Important to do this for line update
						lineObject.verticesNeedUpdate = true;
					 }
					}
				}
			}

			function animate() {
				requestAnimationFrame( animate );
				frameTime = clock.getDelta();
				render();

				UpdateLines();
				stats.update();
			}

			function render() {

				var time = Date.now() * 0.00005;
				camera.position.x += ( mouseX - camera.position.x ) * 0.05;
				camera.position.y += ( - mouseY - camera.position.y ) * 0.05;
				camera.lookAt( scene.position );

        //Color for the dots
				// for ( i = 0; i < materials.length; i ++ ) {
				// 	color = parameters[i][0];
				// 	h = ( 360 * ( color[0] + time ) % 360 ) / 360;
				// 	materials[i].color.setHSL( h, color[1], color[2] );
				// 	lineparam = lineparameters[i];
				// 	h = ( 360 * ( lineparam[1] + time ) % 360 ) / 360;
				// 	linematerials[i].color.setHSL( h, color[1], color[2] );
				// }


        //Wanna rotate?
				//  for ( i = 0; i < scene.children.length; i++ ) {
				//  	var object = scene.children[ i ];
 			 //    object.rotation.y = time * ( i < 4 ? ( i + 1 ) : - ( i + 1 ) );
			  //  }

				//scene.rotation.y = time * ( i < 4 ? ( i + 1 ) : - ( i + 1 ) );

				renderer.render( scene, camera );
			}
		</script>
	</body>
</html>
