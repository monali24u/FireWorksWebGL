<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Fireworks</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				background-color: #000000;
				margin: 0px;
				overflow: hidden;
				font-family:Monospace;
				font-size:13px;
				text-align:center;
				font-weight: bold;
				text-align:center;
			}

			a {
				color:#0078ff;
			}

			#info {
				color: #fff;
				position: absolute;
				top: 0px; width: 100%;
				padding: 5px;
				z-index: 100;
			}

		</style>
	</head>
	<body>

		<script src="build/three.js"></script>
		<script src="js/Detector.js"></script>
		<script src="js/libs/stats.min.js"></script>

		<script>

			if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

      //Global variables
			var container, stats;
			var camera, scene, renderer, particles,  materials = [], parameters, i = 0, j, l, color, size, lines = [];
			var lineparam, lineparameters, linematerials = [], linesgeometry = [];
			var vertexstart, vertexend, fireworksDirection;
			var mouseX = 0, mouseY = 0;
			var speed = 25;
			var nooffireworks = 6;
			var allFireworksReachedDestination = 0;
			var timer;

			var windowHalfX = window.innerWidth / 2;
			var windowHalfY = window.innerHeight / 2;
      var clock = new THREE.Clock();
			var linelength = 50;
			var frameTime = 0;
			var distancetravelled = 0;

			//FireWorks variables
			var ticker = 0;
			var tickermax = 80;
			var fireworktimeout;
			var fireworkstartindex = 0;
			var geometryend = new THREE.Geometry();
			var directiongeometry = new THREE.Geometry();
			var distanceArray = new Array(nooffireworks);

			//Star variables
			var noofstars = 300;
			var starposition;
			var stargeometry = new THREE.Geometry();

			//Particle variables
			var particlescount = 60;
			var particlelength = 20;
			var particlestart;
			var particleend;
			var particlecurrent;
			var particlegeometryend;
			var particledistanceArray = new Array(particlescount);
			var particledirection;
			var particledirectiongeometry = new THREE.Geometry();
			var particleparam, particleparameters, particlematerials = [], particlegeometry = [],  particlelines = [];

			var dustGeometry = new THREE.Geometry();
			var k, dust;
			var dustCount = 600;
			var dustSystem

			init();
			animate();

			// get a random number within a range
			function random( min, max ) {
				return Math.random() * ( max - min ) + min;
			}

			//Remove entity from scene
			function removeEntity(selectedObject)
			 {
    			//var selectedObject = scene.getObjectByName(name);
    			scene.remove( selectedObject );
    		  animate();
			}

			timer = setInterval(function initFireworks()
			{
					//End points of the fireworks
					vertexend = new THREE.Vector3();
					vertexend.x = Math.random() * 2000 - 1000;
					vertexend.y = Math.random() * 2000 - 1000;
					vertexend.z = Math.random() * 2000 - 1000;
					geometryend.vertices.push( vertexend );

					//Starting point of the fireworks
  				vertexstart = new THREE.Vector3();
					vertexstart.x = windowHalfX - 1000;
					vertexstart.y = windowHalfY - 1000;
					vertexstart.z = 0;

					//Compute distance between these two and the direction
					var d = vertexstart.distanceTo( vertexend );
					distanceArray[fireworkstartindex] = d;
					fireworksDirection = new THREE.Vector3();
					fireworksDirection.subVectors( vertexend, vertexstart).normalize();
					directiongeometry.vertices.push( fireworksDirection );

					//Currents point of the fireworks. lets keep the length of the line at 100 units
					vertexcurrent = new THREE.Vector3();
					vertexcurrent.x = (windowHalfX - 1000) + ((fireworksDirection.x) * linelength);
					vertexcurrent.y = (windowHalfY - 1000) + ((fireworksDirection.y) * linelength);
					vertexcurrent.z = 0 								 + ((fireworksDirection.z) * linelength);

					//Create a line from start to current
					lineparameters = [
						//[ 0.25, 0xff9900, 1, 4 ],
						//[ 0.5, 0xff9900, 1, 1 ],
						//[ 0.75, 0xffaa00, 0.75, 1 ],
						[ 1, 0xffaa00, 0.5, 1 ],
						//[ 1.25, 0x000833, 0.8, 1 ],
					];

					linesgeometry[fireworkstartindex] = new THREE.Geometry();
					linesgeometry[fireworkstartindex].vertices.push( new THREE.Vector3(vertexstart.x, vertexstart.y, vertexstart.z) );
					linesgeometry[fireworkstartindex].vertices.push( new THREE.Vector3(vertexcurrent.x, vertexcurrent.y, vertexcurrent.z) );

					//Draws line from origin to all random points
					lineparam = lineparameters[ 0 ];
					linematerials[0] = new THREE.LineBasicMaterial( { color: lineparam[ 1 ], opacity: lineparam[ 2 ], linewidth: lineparam[ 3 ] } );
					lines[fireworkstartindex] = new THREE.LineSegments( linesgeometry[i], linematerials[0] );
					lines[fireworkstartindex].name = "_fireworks"+ fireworkstartindex;
          scene.add( lines[fireworkstartindex] );
					fireworkstartindex++;
					if(fireworkstartindex >= nooffireworks)
					{
						clearTimeout(timer);
					}
				//}
			}, 1500);


       function onemore()
			 {
				 for ( k = 0; k < dustCount; k ++ ) {
 					//End points of the fireworks
 					dust = new THREE.Vector3();
 					dust.x = 0;//Math.random() * 2000 - 1000;
 					dust.y = 0;//Math.random() * 2000 - 1000;
 					dust.z = 0;//Math.random() * 2000 - 1000;
					dust.velocity = new THREE.Vector3( 10, 10, 10);
 					dustGeometry.vertices.push( dust );
 				}

				  var texdustloader = new THREE.TextureLoader();
				  var texdust=texdustloader.load("./images/particle.png");

					// create the particle variables
					var dustMaterial = new THREE.ParticleBasicMaterial({
								 color: 0xFFFFFF,
								 size: 20,
								 map: texdust,
								 blending: THREE.AdditiveBlending,
								 transparent: true,
							 });

  			 // create the particle system
				 dustSystem = new THREE.ParticleSystem(dustGeometry, dustMaterial);
				 dustSystem.sortParticles = true;
				 dustSystem.visible = false;
				 return dustSystem;
			 }

			//Function to create particles when the fireworks reach their destination
			function CreateFireWorksparticles()
			{
				// add some rotation to the system
			   //dustSystem.rotation.y += 0.01;
				//
			  var dCount = dustCount;
			  while (dCount--) {
			    // get the particle
			    var dustp =  dustGeometry.vertices[dCount];

			    // update the velocity with
			    // a splat of randomniz
			    dustp.velocity.x -= Math.random() * .1;
					dustp.velocity.y -= Math.random() * .1;
					dustp.velocity.z -= Math.random() * .1;

			    // and the position
			    dustp.x = dustp.x + dustp.velocity.x;
					dustp.y = dustp.y + dustp.velocity.y;
					dustp.z = dustp.z + dustp.velocity.z;

			  }
				dustSystem.verticesNeedUpdate = true;
				//
			  // // // flag to the particle system
			  // // // that we've changed its vertices.
			   dustSystem.geometry.__dirtyVertices = true;
				//dustSystem.verticesNeedUpdate = true;
			}

			function initStars()
			{
				for ( i = 0; i < noofstars; i ++ ) {
					//End points of the fireworks
					starposition = new THREE.Vector3();
					starposition.x = Math.random() * 2000 - 1000;
					starposition.y = Math.random() * 2000 - 1000;
					starposition.z = Math.random() * 2000 - 1000;
					stargeometry.vertices.push( starposition );
				}
				// parameters = [
				// 	[ [0, 0, 1], 2 ],
				// 	//[ [1, 1, 0.5], 5 ],
				// 	//[ [1, 1, 0.5], 5 ],
				// 	//[ [1, 1, 0.5], 5 ],
				// 	//[ [1, 1, 0.5], 5 ]
				// ];

				var texloader = new THREE.TextureLoader();
				var tex=texloader.load("./images/stars.png");

				var particleMaterial = new THREE.PointsMaterial(
            {color: 0xffffff,
             size: 25,
						 map: tex,
             blending: THREE.AdditiveBlending,
             transparent: true,
            });

        //var p;
				//for ( i = 0; i < parameters.length; i ++ ) {

					// color = parameters[i][0];
					// size  = parameters[i][1];
					//
					// materials[i] = new THREE.PointsMaterial( { size: size } );
					particles = new THREE.Points( stargeometry,particleMaterial );
					return particles;
				//}
			}

			function init()
			 {

				container = document.createElement( 'div' );
				document.body.appendChild( container );

				camera = new THREE.PerspectiveCamera( 100, window.innerWidth / window.innerHeight, 1, 1000 );
				camera.position.z = 500;

				scene = new THREE.Scene();
				scene.fog = new THREE.FogExp2( 0x000000, 0.0007 );

				//Initialize stars
				particles = initStars();
				scene.add( particles );


				dustSystem = onemore();
				scene.add(dustSystem);

				renderer = new THREE.WebGLRenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				container.appendChild( renderer.domElement );

				stats = new Stats();
				container.appendChild( stats.dom );

				document.addEventListener( 'mousemove', onDocumentMouseMove, false );
				document.addEventListener( 'touchstart', onDocumentTouchStart, false );
				document.addEventListener( 'touchmove', onDocumentTouchMove, false );
				window.addEventListener( 'resize', onWindowResize, false );
			}

			function onWindowResize() {

				windowHalfX = window.innerWidth / 2;
				windowHalfY = window.innerHeight / 2;

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function onDocumentMouseMove( event ) {

				mouseX = event.clientX - windowHalfX;
				mouseY = event.clientY - windowHalfY;

			}

			function onDocumentTouchStart( event ) {

				if ( event.touches.length === 1 ) {

					event.preventDefault();

					mouseX = event.touches[ 0 ].pageX - windowHalfX;
					mouseY = event.touches[ 0 ].pageY - windowHalfY;

				}

			}

			function onDocumentTouchMove( event ) {

				if ( event.touches.length === 1 ) {

					event.preventDefault();

					mouseX = event.touches[ 0 ].pageX - windowHalfX;
					mouseY = event.touches[ 0 ].pageY - windowHalfY;

				}

			}

			//Function to update the lines
      function UpdateLines() {
			for ( i = 0; i < linesgeometry.length; i++ )
				{
					var lineObject = linesgeometry[ i ];
					var fromPoint = lineObject.vertices[ 0 ];
					var toPoint   = lineObject.vertices[ 1 ];
					var endPoint  = geometryend.vertices[i];

					if ( toPoint instanceof THREE.Vector3 )
					{
						//If we are at the destination then we just need to disperse the fire particles
						var distance = vertexstart.distanceTo( toPoint );
						if(distance > distanceArray[i])
						{
              lines[i].visible = false;
							var dCount = dustCount;
							while (dCount--)
							 {
								// get the particle
								var dustp =  dustGeometry.vertices[dCount];
								// and the position
								dustp.x = toPoint.x;
								dustp.y = toPoint.y;
								dustp.z = toPoint.z;
							}
              //SdustGeometry..verticesNeedUpdate = true;
							dustSystem.verticesNeedUpdate = true;
							dustSystem.visible = true;
							//CreateFireWorksparticles();
						}
					else
					 {
						//Calculate the distance travelled in the elaspsed time and hence the new toPoint
						distancetravelled = speed * frameTime * 10;
						var directionVertice = directiongeometry.vertices[ i ];
						if ( directionVertice instanceof THREE.Vector3 )
						{
							toPoint.x = toPoint.x + ((directionVertice.x) * distancetravelled);
							toPoint.y = toPoint.y + ((directionVertice.y) * distancetravelled);
							toPoint.z = toPoint.z + ((directionVertice.z) * distancetravelled);
						}

						//Update the fromPoint to trail linelength behind toPoint
						 fromPoint.x = toPoint.x + ((directionVertice.x) * -linelength);
						 fromPoint.y = toPoint.y + ((directionVertice.y) * -linelength);
						 fromPoint.z = toPoint.z + ((directionVertice.z) * -linelength);

						//Important to do this for line update
						lineObject.verticesNeedUpdate = true;
					 }
					}
				}
			}

			function animate() {
				requestAnimationFrame( animate );
				frameTime = clock.getDelta();
				render();
				UpdateLines();
				//UpdateParticles();
				stats.update();
			}

			function render() {

				var time = Date.now() * 0.00005;
				camera.position.x += ( mouseX - camera.position.x ) * 0.05;
				camera.position.y += ( - mouseY - camera.position.y ) * 0.05;
				camera.lookAt( scene.position );

				if(dustSystem.visible)
				{
					var dCount = dustCount;
				  while (dCount--) {
				    // get the particle
				    var dustp =  dustGeometry.vertices[dCount];

				    // update the velocity with
				    // a splat of randomniz
				    // dustp.velocity.x -= Math.random() * .1;
						// dustp.velocity.y -= Math.random() * .1;
						// dustp.velocity.z -= Math.random() * .1;
						//
				    // // and the position
				    // dustp.x = dustp.x + dustp.velocity.x;
						// dustp.y = dustp.y + dustp.velocity.y;
						// dustp.z = dustp.z + dustp.velocity.z;
						dustp.x = 0;
						dustp.y = 0;
						dustp.z = 0;
				  }
					 dustSystem.verticesNeedUpdate = true;
			 }
				// //
			  // // // // flag to the particle system
			  // // // // that we've changed its vertices.
			  //  dustSystem.geometry.__dirtyVertices = true;
				//



					//		var pCount = particleCount1;
				// while(pCount--) {
				// 	// get the particle
				// 	var particle2 = particles1.vertices[pCount];
				//
				// 	// check if we need to reset
				// 	if(particle2.position.y < -200) {
				// 		particle2.position.y = 200;
				// 		particle2.velocity.y = 0;
				// 	}
				//
				// 	// update the velocity
				// 	particle2.velocity.y -= Math.random() * .1;
				//
				// 	// and the position
				// 	particle2.position.addSelf(
				// 		particle2.velocity);
				// }
				//
				// // flag to the particle system that we've
				// // changed its vertices. This is the
				// // dirty little secret.
				// particleSystem1.geometry.__dirtyVertices = true;


        //Color for the dots
				// for ( i = 0; i < materials.length; i ++ ) {
				// 	color = parameters[i][0];
				// 	l = time/100000000;// * Math.random(0, 1);
				// 	if(l < 0 || l > 1)
				// 	 l = 1;
				// 	 alert(l);
				// 	 materials[i].color.setHSL( color[0], color[1], l );
				// }


        //Wanna rotate?
				//  for ( i = 0; i < scene.children.length; i++ ) {
				//  	var object = scene.children[ i ];
 			 //    object.rotation.y = time * ( i < 4 ? ( i + 1 ) : - ( i + 1 ) );
			  //  }

				//scene.rotation.y = time * ( i < 4 ? ( i + 1 ) : - ( i + 1 ) );

				renderer.render( scene, camera );
			}
		</script>
	</body>
</html>
